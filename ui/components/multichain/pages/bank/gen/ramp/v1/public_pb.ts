// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file ramp/v1/public.proto (package ramp.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage
} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64, Timestamp} from "@bufbuild/protobuf";

/**
 * @generated from enum ramp.v1.RampType
 */
export enum RampType {
  /**
   * @generated from enum value: RAMP_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RAMP_TYPE_ON_RAMP = 10;
   */
  ON_RAMP = 10,

  /**
   * @generated from enum value: RAMP_TYPE_OFF_RAMP = 20;
   */
  OFF_RAMP = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(RampType)
proto3.util.setEnumType(RampType, "ramp.v1.RampType", [
  { no: 0, name: "RAMP_TYPE_UNSPECIFIED" },
  { no: 10, name: "RAMP_TYPE_ON_RAMP" },
  { no: 20, name: "RAMP_TYPE_OFF_RAMP" },
]);

/**
 * @generated from enum ramp.v1.RampStatus
 */
export enum RampStatus {
  /**
   * @generated from enum value: RAMP_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RAMP_STATUS_PENDING = 10;
   */
  PENDING = 10,

  /**
   * @generated from enum value: RAMP_STATUS_COMPLETED = 20;
   */
  COMPLETED = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(RampStatus)
proto3.util.setEnumType(RampStatus, "ramp.v1.RampStatus", [
  { no: 0, name: "RAMP_STATUS_UNSPECIFIED" },
  { no: 10, name: "RAMP_STATUS_PENDING" },
  { no: 20, name: "RAMP_STATUS_COMPLETED" },
]);

/**
 * @generated from enum ramp.v1.Ecosystem
 */
export enum Ecosystem {
  /**
   * @generated from enum value: ECOSYSTEM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * any EVM compatible chain - addresses are expected to be the right-most 160 bits of the keccak256 hash of the public key
   *
   * @generated from enum value: ECOSYSTEM_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * any Cosmos ecosystem chain - addresses are expected to be compatible with the Cosmos SDK (such as 160 bit BECH32)
   *
   * @generated from enum value: ECOSYSTEM_COSMOS = 20;
   */
  COSMOS = 20,

  /**
   * any Substrate ecosystem chain - addresses are expected to be compatible with Substrate (overal 256bit SS58)
   *
   * @generated from enum value: ECOSYSTEM_SUBSTRATE = 30;
   */
  SUBSTRATE = 30,
}
// Retrieve enum metadata with: proto3.getEnumType(Ecosystem)
proto3.util.setEnumType(Ecosystem, "ramp.v1.Ecosystem", [
  { no: 0, name: "ECOSYSTEM_UNSPECIFIED" },
  { no: 10, name: "ECOSYSTEM_ETHEREUM" },
  { no: 20, name: "ECOSYSTEM_COSMOS" },
  { no: 30, name: "ECOSYSTEM_SUBSTRATE" },
]);

/**
 * @generated from enum ramp.v1.Protocol
 */
export enum Protocol {
  /**
   * @generated from enum value: PROTOCOL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PROTOCOL_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * @generated from enum value: PROTOCOL_AVAX = 20;
   */
  AVAX = 20,

  /**
   * @generated from enum value: PROTOCOL_TERRA = 30;
   */
  TERRA = 30,

  /**
   * @generated from enum value: PROTOCOL_POLYGON = 40;
   */
  POLYGON = 40,

  /**
   * @generated from enum value: PROTOCOL_ALEPH_ZERO = 50 [deprecated = true];
   * @deprecated
   */
  ALEPH_ZERO = 50,

  /**
   * @generated from enum value: PROTOCOL_ALEPH_ZERO_L2 = 60;
   */
  ALEPH_ZERO_L2 = 60,

  /**
   * @generated from enum value: PROTOCOL_POLKADOT = 70;
   */
  POLKADOT = 70,

  /**
   * @generated from enum value: PROTOCOL_NOBLE = 80;
   */
  NOBLE = 80,
}
// Retrieve enum metadata with: proto3.getEnumType(Protocol)
proto3.util.setEnumType(Protocol, "ramp.v1.Protocol", [
  { no: 0, name: "PROTOCOL_UNSPECIFIED" },
  { no: 10, name: "PROTOCOL_ETHEREUM" },
  { no: 20, name: "PROTOCOL_AVAX" },
  { no: 30, name: "PROTOCOL_TERRA" },
  { no: 40, name: "PROTOCOL_POLYGON" },
  { no: 50, name: "PROTOCOL_ALEPH_ZERO" },
  { no: 60, name: "PROTOCOL_ALEPH_ZERO_L2" },
  { no: 70, name: "PROTOCOL_POLKADOT" },
  { no: 80, name: "PROTOCOL_NOBLE" },
]);

/**
 * An AssetId helps the client to identify an exact token and customise the UI.
 * The AssetId is universal across all chains, in fact our responses always include the Network, and the AssetID.
 * So ASSET_ID_USDC will always be the official Circle USDC on any chain, be that Ethereum, or Avalanche, or Polygon.
 *
 * @generated from enum ramp.v1.AssetId
 */
export enum AssetId {
  /**
   * @generated from enum value: ASSET_ID_UNSPECIFIED = 0;
   */
  ASSET_ID_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ASSET_ID_USDC = 10;
   */
  ASSET_ID_USDC = 10,

  /**
   * @generated from enum value: ASSET_ID_AXL_USDC = 20;
   */
  ASSET_ID_AXL_USDC = 20,

  /**
   * @generated from enum value: ASSET_ID_1USD = 30;
   */
  ASSET_ID_1USD = 30,

  /**
   * @generated from enum value: ASSET_ID_ETH = 40;
   */
  ASSET_ID_ETH = 40,

  /**
   * @generated from enum value: ASSET_ID_DOT = 50;
   */
  ASSET_ID_DOT = 50,

  /**
   * @generated from enum value: ASSET_ID_USDE = 60;
   */
  ASSET_ID_USDE = 60,
}
// Retrieve enum metadata with: proto3.getEnumType(AssetId)
proto3.util.setEnumType(AssetId, "ramp.v1.AssetId", [
  { no: 0, name: "ASSET_ID_UNSPECIFIED" },
  { no: 10, name: "ASSET_ID_USDC" },
  { no: 20, name: "ASSET_ID_AXL_USDC" },
  { no: 30, name: "ASSET_ID_1USD" },
  { no: 40, name: "ASSET_ID_ETH" },
  { no: 50, name: "ASSET_ID_DOT" },
  { no: 60, name: "ASSET_ID_USDE" },
]);

/**
 * @generated from enum ramp.v1.CurrencyId
 */
export enum CurrencyId {
  /**
   * @generated from enum value: CURRENCY_ID_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CURRENCY_ID_EUR = 10;
   */
  EUR = 10,

  /**
   * @generated from enum value: CURRENCY_ID_GBP = 20;
   */
  GBP = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(CurrencyId)
proto3.util.setEnumType(CurrencyId, "ramp.v1.CurrencyId", [
  { no: 0, name: "CURRENCY_ID_UNSPECIFIED" },
  { no: 10, name: "CURRENCY_ID_EUR" },
  { no: 20, name: "CURRENCY_ID_GBP" },
]);

/**
 * @generated from enum ramp.v1.Network
 */
export enum Network {
  /**
   * @generated from enum value: NETWORK_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_MAINNET = 10;
   */
  ETHEREUM_MAINNET = 10,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_SEPOLIA = 20;
   */
  ETHEREUM_SEPOLIA = 20,

  /**
   * @generated from enum value: NETWORK_AVAX_FUJI = 30;
   */
  AVAX_FUJI = 30,

  /**
   * @generated from enum value: NETWORK_AVAX_C_MAINNET = 40;
   */
  AVAX_C_MAINNET = 40,

  /**
   * @generated from enum value: NETWORK_TERRA2_MAINNET = 50;
   */
  TERRA2_MAINNET = 50,

  /**
   * @generated from enum value: NETWORK_POLYGON_MAINNET = 60;
   */
  POLYGON_MAINNET = 60,

  /**
   * @generated from enum value: NETWORK_POLYGON_AMOY = 70;
   */
  POLYGON_AMOY = 70,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_MAINNET = 80;
   */
  ALEPH_ZERO_MAINNET = 80,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_TESTNET = 90;
   */
  ALEPH_ZERO_TESTNET = 90,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_L2_MAINNET = 100;
   */
  ALEPH_ZERO_L2_MAINNET = 100,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_L2_TESTNET = 110;
   */
  ALEPH_ZERO_L2_TESTNET = 110,

  /**
   * @generated from enum value: NETWORK_POLKADOT_MAINNET = 120;
   */
  POLKADOT_MAINNET = 120,

  /**
   * @generated from enum value: NETWORK_POLKADOT_TESTNET = 130;
   */
  POLKADOT_TESTNET = 130,

  /**
   * @generated from enum value: NETWORK_NOBLE_MAINNET = 140;
   */
  NOBLE_MAINNET = 140,

  /**
   * @generated from enum value: NETWORK_NOBLE_TESTNET = 150;
   */
  NOBLE_TESTNET = 150,
}
// Retrieve enum metadata with: proto3.getEnumType(Network)
proto3.util.setEnumType(Network, "ramp.v1.Network", [
  { no: 0, name: "NETWORK_UNSPECIFIED" },
  { no: 10, name: "NETWORK_ETHEREUM_MAINNET" },
  { no: 20, name: "NETWORK_ETHEREUM_SEPOLIA" },
  { no: 30, name: "NETWORK_AVAX_FUJI" },
  { no: 40, name: "NETWORK_AVAX_C_MAINNET" },
  { no: 50, name: "NETWORK_TERRA2_MAINNET" },
  { no: 60, name: "NETWORK_POLYGON_MAINNET" },
  { no: 70, name: "NETWORK_POLYGON_AMOY" },
  { no: 80, name: "NETWORK_ALEPH_ZERO_MAINNET" },
  { no: 90, name: "NETWORK_ALEPH_ZERO_TESTNET" },
  { no: 100, name: "NETWORK_ALEPH_ZERO_L2_MAINNET" },
  { no: 110, name: "NETWORK_ALEPH_ZERO_L2_TESTNET" },
  { no: 120, name: "NETWORK_POLKADOT_MAINNET" },
  { no: 130, name: "NETWORK_POLKADOT_TESTNET" },
  { no: 140, name: "NETWORK_NOBLE_MAINNET" },
  { no: 150, name: "NETWORK_NOBLE_TESTNET" },
]);

/**
 * @generated from message ramp.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoRequest
 */
export class GetAccountInfoRequest extends Message<GetAccountInfoRequest> {
  /**
   * @generated from field: optional string referral_code = 10;
   */
  referralCode?: string;

  constructor(data?: PartialMessage<GetAccountInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "referral_code", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoRequest | PlainMessage<GetAccountInfoRequest> | undefined, b: GetAccountInfoRequest | PlainMessage<GetAccountInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse
 */
export class GetAccountInfoResponse extends Message<GetAccountInfoResponse> {
  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.result
   */
  result: {
    /**
     * when result is authentication user needs to be onboarded or logged in
     *
     * @generated from field: ramp.v1.GetAccountInfoResponse.Authentication authentication = 20;
     */
    value: GetAccountInfoResponse_Authentication;
    case: "authentication";
  } | {
    /**
     * when result is account user is logged
     *
     * @generated from field: ramp.v1.GetAccountInfoResponse.Account account = 30;
     */
    value: GetAccountInfoResponse_Account;
    case: "account";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetAccountInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "authentication", kind: "message", T: GetAccountInfoResponse_Authentication, oneof: "result" },
    { no: 30, name: "account", kind: "message", T: GetAccountInfoResponse_Account, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse | PlainMessage<GetAccountInfoResponse> | undefined, b: GetAccountInfoResponse | PlainMessage<GetAccountInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Authentication
 */
export class GetAccountInfoResponse_Authentication extends Message<GetAccountInfoResponse_Authentication> {
  /**
   * authentication_url should be loaded in the i-frame or browser window in order to log in or onboard user
   *
   * @generated from field: string authentication_url = 10;
   */
  authenticationUrl = "";

  /**
   * token expiry in seconds, the frontend is expected to close the onboarding view (but the user can come back any time)
   * don't worry about the time skew from api latency, there's a grace period on top of this expiry
   *
   * @generated from field: int64 expires_in_sec = 20;
   */
  expiresInSec = protoInt64.zero;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Authentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Authentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "authentication_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "expires_in_sec", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Authentication | PlainMessage<GetAccountInfoResponse_Authentication> | undefined, b: GetAccountInfoResponse_Authentication | PlainMessage<GetAccountInfoResponse_Authentication> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Authentication, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Account
 */
export class GetAccountInfoResponse_Account extends Message<GetAccountInfoResponse_Account> {
  /**
   * list of whitelisted addresses. On-ramping could be done only to whitelisted address
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet wallets = 10;
   */
  wallets: GetAccountInfoResponse_Wallet[] = [];

  /**
   * A bank account created by Harbour in the name of the user, where funds can be sent
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.onramp_bank_account
   */
  onrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates onramp_scan = 100;
     */
    value: ScanCoordinates;
    case: "onrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates onramp_iban = 110;
     */
    value: IbanCoordinates;
    case: "onrampIban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A bank account set by the user for off-ramping, see rpc SetBankAccount
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.offramp_bank_account
   */
  offrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates offramp_scan = 200;
     */
    value: ScanCoordinates;
    case: "offrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates offramp_iban = 210;
     */
    value: IbanCoordinates;
    case: "offrampIban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * account holder name for on and off-ramping
   *
   * @generated from field: string account_holder = 20;
   */
  accountHolder = "";

  /**
   * list of supported assets
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.CryptoAsset crypto_assets = 30;
   */
  cryptoAssets: GetAccountInfoResponse_CryptoAsset[] = [];

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.AccountLimits limits = 40;
   */
  limits?: GetAccountInfoResponse_AccountLimits;

  /**
   * Field is optional as it depends on downstream microservices. In case of error
   * fetching points, we want this API to keep working. If this ends up being null,
   * the client should show something like N/A or 'error fetching points' to the 
   * user, but not 0 points, to avoid alarming them.
   *
   * @generated from field: optional ramp.v1.GetAccountInfoResponse.Account.Reward reward = 50;
   */
  reward?: GetAccountInfoResponse_Account_Reward;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Account>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Account";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "wallets", kind: "message", T: GetAccountInfoResponse_Wallet, repeated: true },
    { no: 100, name: "onramp_scan", kind: "message", T: ScanCoordinates, oneof: "onramp_bank_account" },
    { no: 110, name: "onramp_iban", kind: "message", T: IbanCoordinates, oneof: "onramp_bank_account" },
    { no: 200, name: "offramp_scan", kind: "message", T: ScanCoordinates, oneof: "offramp_bank_account" },
    { no: 210, name: "offramp_iban", kind: "message", T: IbanCoordinates, oneof: "offramp_bank_account" },
    { no: 20, name: "account_holder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "crypto_assets", kind: "message", T: GetAccountInfoResponse_CryptoAsset, repeated: true },
    { no: 40, name: "limits", kind: "message", T: GetAccountInfoResponse_AccountLimits },
    { no: 50, name: "reward", kind: "message", T: GetAccountInfoResponse_Account_Reward, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Account | PlainMessage<GetAccountInfoResponse_Account> | undefined, b: GetAccountInfoResponse_Account | PlainMessage<GetAccountInfoResponse_Account> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Account, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Account.Reward
 */
export class GetAccountInfoResponse_Account_Reward extends Message<GetAccountInfoResponse_Account_Reward> {
  /**
   * the amount of reward points the user has earned
   *
   * @generated from field: int64 points = 10;
   */
  points = protoInt64.zero;

  /**
   * referral code the user can use to refer others and earn more points
   *
   * @generated from field: string referral_code = 20;
   */
  referralCode = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Account_Reward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Account.Reward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "points", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 20, name: "referral_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Account_Reward {
    return new GetAccountInfoResponse_Account_Reward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account_Reward {
    return new GetAccountInfoResponse_Account_Reward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account_Reward {
    return new GetAccountInfoResponse_Account_Reward().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Account_Reward | PlainMessage<GetAccountInfoResponse_Account_Reward> | undefined, b: GetAccountInfoResponse_Account_Reward | PlainMessage<GetAccountInfoResponse_Account_Reward> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Account_Reward, a, b);
  }
}

/**
 * Deprecated
 *
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset
 */
export class GetAccountInfoResponse_CryptoAsset extends Message<GetAccountInfoResponse_CryptoAsset> {
  /**
   * asset status for on/off ramping
   *
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus status = 1;
   */
  status?: GetAccountInfoResponse_CryptoAsset_RampStatus;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 5;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Network network = 10;
   */
  network = Network.UNSPECIFIED;

  /**
   * the client can use this to match an asset with precision and display custom wording / icon, e.g. "USDC"
   *
   * @generated from field: ramp.v1.AssetId asset_id = 20;
   */
  assetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
   *
   * @generated from field: string short_name = 30;
   */
  shortName = "";

  /**
   * the canonical symbol for the asset - eg: USDC for any Circle-issued USDC on any chain, or ETH for Ethereum
   *
   * @generated from field: string symbol = 35;
   */
  symbol = "";

  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.CryptoAsset.details
   */
  details: {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token ethereum_erc20_token = 40;
     */
    value: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token;
    case: "ethereumErc20Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token cosmos_ics20_token = 50;
     */
    value: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token;
    case: "cosmosIcs20Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token substrate_psp22_token = 60;
     */
    value: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token;
    case: "substratePsp22Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative ethereum_native = 70;
     */
    value: GetAccountInfoResponse_CryptoAsset_EthereumNative;
    case: "ethereumNative";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: GetAccountInfoResponse_CryptoAsset_RampStatus },
    { no: 5, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 10, name: "network", kind: "enum", T: proto3.getEnumType(Network) },
    { no: 20, name: "asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 30, name: "short_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 35, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "ethereum_erc20_token", kind: "message", T: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token, oneof: "details" },
    { no: 50, name: "cosmos_ics20_token", kind: "message", T: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token, oneof: "details" },
    { no: 60, name: "substrate_psp22_token", kind: "message", T: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token, oneof: "details" },
    { no: 70, name: "ethereum_native", kind: "message", T: GetAccountInfoResponse_CryptoAsset_EthereumNative, oneof: "details" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset {
    return new GetAccountInfoResponse_CryptoAsset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset {
    return new GetAccountInfoResponse_CryptoAsset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset {
    return new GetAccountInfoResponse_CryptoAsset().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset | PlainMessage<GetAccountInfoResponse_CryptoAsset> | undefined, b: GetAccountInfoResponse_CryptoAsset | PlainMessage<GetAccountInfoResponse_CryptoAsset> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token
 */
export class GetAccountInfoResponse_CryptoAsset_EthereumErc20Token extends Message<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> {
  /**
   * ERC20 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumErc20Token {
    return new GetAccountInfoResponse_CryptoAsset_EthereumErc20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumErc20Token {
    return new GetAccountInfoResponse_CryptoAsset_EthereumErc20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumErc20Token {
    return new GetAccountInfoResponse_CryptoAsset_EthereumErc20Token().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> | undefined, b: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_EthereumErc20Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token
 */
export class GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token extends Message<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> {
  /**
   * IBC token address
   *
   * @generated from field: string ibc_address = 10;
   */
  ibcAddress = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "ibc_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token {
    return new GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token {
    return new GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token {
    return new GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> | undefined, b: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token
 */
export class GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token extends Message<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> {
  /**
   * Substrate PSP22 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token {
    return new GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token {
    return new GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token {
    return new GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> | undefined, b: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token | PlainMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative
 */
export class GetAccountInfoResponse_CryptoAsset_EthereumNative extends Message<GetAccountInfoResponse_CryptoAsset_EthereumNative> {
  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_EthereumNative>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumNative {
    return new GetAccountInfoResponse_CryptoAsset_EthereumNative().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumNative {
    return new GetAccountInfoResponse_CryptoAsset_EthereumNative().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_EthereumNative {
    return new GetAccountInfoResponse_CryptoAsset_EthereumNative().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_EthereumNative | PlainMessage<GetAccountInfoResponse_CryptoAsset_EthereumNative> | undefined, b: GetAccountInfoResponse_CryptoAsset_EthereumNative | PlainMessage<GetAccountInfoResponse_CryptoAsset_EthereumNative> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_EthereumNative, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus
 */
export class GetAccountInfoResponse_CryptoAsset_RampStatus extends Message<GetAccountInfoResponse_CryptoAsset_RampStatus> {
  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status onramp = 10;
   */
  onramp = GetAccountInfoResponse_CryptoAsset_RampStatus_Status.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status offramp = 20;
   */
  offramp = GetAccountInfoResponse_CryptoAsset_RampStatus_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<GetAccountInfoResponse_CryptoAsset_RampStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "onramp", kind: "enum", T: proto3.getEnumType(GetAccountInfoResponse_CryptoAsset_RampStatus_Status) },
    { no: 20, name: "offramp", kind: "enum", T: proto3.getEnumType(GetAccountInfoResponse_CryptoAsset_RampStatus_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_CryptoAsset_RampStatus {
    return new GetAccountInfoResponse_CryptoAsset_RampStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_RampStatus {
    return new GetAccountInfoResponse_CryptoAsset_RampStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_CryptoAsset_RampStatus {
    return new GetAccountInfoResponse_CryptoAsset_RampStatus().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_CryptoAsset_RampStatus | PlainMessage<GetAccountInfoResponse_CryptoAsset_RampStatus> | undefined, b: GetAccountInfoResponse_CryptoAsset_RampStatus | PlainMessage<GetAccountInfoResponse_CryptoAsset_RampStatus> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_CryptoAsset_RampStatus, a, b);
  }
}

/**
 * @generated from enum ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status
 */
export enum GetAccountInfoResponse_CryptoAsset_RampStatus_Status {
  /**
   * All is good, asset can be on/off ramped
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Our system is experiencing degradation (longer waits) but still operational.
   * The UI should warn users.
   *
   * @generated from enum value: STATUS_DEGRADED = 20;
   */
  DEGRADED = 20,

  /**
   * Exceptional scenarios: ramping halted. The UI should prevent users from taking any action.
   *
   * @generated from enum value: STATUS_HALTED = 30;
   */
  HALTED = 30,
}
// Retrieve enum metadata with: proto3.getEnumType(GetAccountInfoResponse_CryptoAsset_RampStatus_Status)
proto3.util.setEnumType(GetAccountInfoResponse_CryptoAsset_RampStatus_Status, "ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 20, name: "STATUS_DEGRADED" },
  { no: 30, name: "STATUS_HALTED" },
]);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet
 */
export class GetAccountInfoResponse_Wallet extends Message<GetAccountInfoResponse_Wallet> {
  /**
   * user given name, less then 100 symbols
   *
   * @generated from field: string name = 5;
   */
  name = "";

  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * address of a wallet in blockchain
   *
   * @generated from field: string address = 20;
   */
  address = "";

  /**
   * assets available for on- and off- ramping
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet.RampAsset assets = 30;
   */
  assets: GetAccountInfoResponse_Wallet_RampAsset[] = [];

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 20, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "assets", kind: "message", T: GetAccountInfoResponse_Wallet_RampAsset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet | PlainMessage<GetAccountInfoResponse_Wallet> | undefined, b: GetAccountInfoResponse_Wallet | PlainMessage<GetAccountInfoResponse_Wallet> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.RampAsset
 */
export class GetAccountInfoResponse_Wallet_RampAsset extends Message<GetAccountInfoResponse_Wallet_RampAsset> {
  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset asset = 10;
   */
  asset?: GetAccountInfoResponse_CryptoAsset;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OnRamp on_ramp = 20;
   */
  onRamp?: GetAccountInfoResponse_Wallet_OnRamp;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OffRamp off_ramp = 30;
   */
  offRamp?: GetAccountInfoResponse_Wallet_OffRamp;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_RampAsset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.RampAsset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "asset", kind: "message", T: GetAccountInfoResponse_CryptoAsset },
    { no: 20, name: "on_ramp", kind: "message", T: GetAccountInfoResponse_Wallet_OnRamp },
    { no: 30, name: "off_ramp", kind: "message", T: GetAccountInfoResponse_Wallet_OffRamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_RampAsset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset> | undefined, b: GetAccountInfoResponse_Wallet_RampAsset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_RampAsset, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OnRamp
 */
export class GetAccountInfoResponse_Wallet_OnRamp extends Message<GetAccountInfoResponse_Wallet_OnRamp> {
  /**
   * e.g. "ETU1"
   *
   * @generated from field: string payment_reference = 10;
   */
  paymentReference = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_OnRamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.OnRamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "payment_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_OnRamp | PlainMessage<GetAccountInfoResponse_Wallet_OnRamp> | undefined, b: GetAccountInfoResponse_Wallet_OnRamp | PlainMessage<GetAccountInfoResponse_Wallet_OnRamp> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_OnRamp, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OffRamp
 */
export class GetAccountInfoResponse_Wallet_OffRamp extends Message<GetAccountInfoResponse_Wallet_OffRamp> {
  /**
   * address, crypto asset should be send to for offramping
   *
   * @generated from field: string address = 10;
   */
  address = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_OffRamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.OffRamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_OffRamp | PlainMessage<GetAccountInfoResponse_Wallet_OffRamp> | undefined, b: GetAccountInfoResponse_Wallet_OffRamp | PlainMessage<GetAccountInfoResponse_Wallet_OffRamp> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_OffRamp, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.AccountLimits
 */
export class GetAccountInfoResponse_AccountLimits extends Message<GetAccountInfoResponse_AccountLimits> {
  /**
   * limit for single on-ramp in fiat currency
   *
   * @generated from field: string onramp_single_limit = 10;
   */
  onrampSingleLimit = "";

  /**
   * daily limit for on-ramp in fiat currency
   *
   * @generated from field: string onramp_daily_limit = 20;
   */
  onrampDailyLimit = "";

  /**
   * current usage for on-ramp in fiat currency
   *
   * @generated from field: string onramp_current_daily_usage = 30;
   */
  onrampCurrentDailyUsage = "";

  /**
   * single limit for off-ramp expressed in fiat currency (either EUR or GBP)
   *
   * @generated from field: string offramp_single_limit = 40;
   */
  offrampSingleLimit = "";

  /**
   * daily limit for off-ramp expressed in fiat currency (either EUR or GBP)
   *
   * @generated from field: string offramp_daily_limit = 50;
   */
  offrampDailyLimit = "";

  /**
   * current usage for off-ramp expressed in fiat currency (either EUR or GBP)
   *
   * @generated from field: string offramp_current_daily_usage = 60;
   */
  offrampCurrentDailyUsage = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_AccountLimits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.AccountLimits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "onramp_single_limit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "onramp_daily_limit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "onramp_current_daily_usage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "offramp_single_limit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "offramp_daily_limit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "offramp_current_daily_usage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_AccountLimits {
    return new GetAccountInfoResponse_AccountLimits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_AccountLimits {
    return new GetAccountInfoResponse_AccountLimits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_AccountLimits {
    return new GetAccountInfoResponse_AccountLimits().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_AccountLimits | PlainMessage<GetAccountInfoResponse_AccountLimits> | undefined, b: GetAccountInfoResponse_AccountLimits | PlainMessage<GetAccountInfoResponse_AccountLimits> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_AccountLimits, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressRequest
 */
export class WhitelistAddressRequest extends Message<WhitelistAddressRequest> {
  /**
   * user given name, could be same name as in the Self Custody wallet if supported by wallet vendor
   * (the maximum length of the name is 100 symbols)
   *
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * Ethereum, Avalanche, Terra and etc.
   *
   * @generated from field: ramp.v1.Protocol protocol = 20;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   * Deprecated in favour of signed_address
   *
   * limited to 255 characters
   *
   * @generated from field: string address = 30 [deprecated = true];
   * @deprecated
   */
  address = "";

  /**
   * address must be derived from the provided public key
   * public key in particular ecosystem, encoded accordingly to ecosystem rules (Ethereum - hex, Cosmos - base64)
   * Deprecated in favour of signed_address
   *
   * limited to 255 characters
   *
   * @generated from field: string public_key = 35 [deprecated = true];
   * @deprecated
   */
  publicKey = "";

  /**
   * the address should be signed with its private key
   * for the Ethereum: the address should be signed with https://docs.metamask.io/wallet/reference/personal_sign/
   * Deprecated in favour of signed_address
   *
   * @generated from field: string address_signature = 40 [deprecated = true];
   * @deprecated
   */
  addressSignature = "";

  /**
   * this field is only required when the public key used to authenticate this request is different from the key used to derive the address
   * if this field is present in the request it takes precedence over the address, public_key and address_signature of the WhitelistAddressRequest
   *
   * @generated from field: ramp.v1.WhitelistAddressRequest.SignedAddress signed_address = 50;
   */
  signedAddress?: WhitelistAddressRequest_SignedAddress;

  constructor(data?: PartialMessage<WhitelistAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 35, name: "public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "address_signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "signed_address", kind: "message", T: WhitelistAddressRequest_SignedAddress },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressRequest | PlainMessage<WhitelistAddressRequest> | undefined, b: WhitelistAddressRequest | PlainMessage<WhitelistAddressRequest> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressRequest.SignedAddress
 */
export class WhitelistAddressRequest_SignedAddress extends Message<WhitelistAddressRequest_SignedAddress> {
  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * limited to 255 characters
   *
   * @generated from field: string address = 30;
   */
  address = "";

  /**
   * address must be derived from the provided public key
   * public key in particular ecosystem, encoded accordingly to ecosystem rules (Ethereum - hex, Cosmos - base64)
   *
   * limited to 255 characters
   *
   * @generated from field: string public_key = 35;
   */
  publicKey = "";

  /**
   * the address should be signed with its private key
   * for the Ethereum: the address should be signed with https://docs.metamask.io/wallet/reference/personal_sign/
   *
   * @generated from field: string address_signature = 40;
   */
  addressSignature = "";

  constructor(data?: PartialMessage<WhitelistAddressRequest_SignedAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressRequest.SignedAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 35, name: "public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "address_signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressRequest_SignedAddress {
    return new WhitelistAddressRequest_SignedAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressRequest_SignedAddress {
    return new WhitelistAddressRequest_SignedAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressRequest_SignedAddress {
    return new WhitelistAddressRequest_SignedAddress().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressRequest_SignedAddress | PlainMessage<WhitelistAddressRequest_SignedAddress> | undefined, b: WhitelistAddressRequest_SignedAddress | PlainMessage<WhitelistAddressRequest_SignedAddress> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressRequest_SignedAddress, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressResponse
 */
export class WhitelistAddressResponse extends Message<WhitelistAddressResponse> {
  constructor(data?: PartialMessage<WhitelistAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressResponse | PlainMessage<WhitelistAddressResponse> | undefined, b: WhitelistAddressResponse | PlainMessage<WhitelistAddressResponse> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.RemoveAddressRequest
 */
export class RemoveAddressRequest extends Message<RemoveAddressRequest> {
  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * @generated from field: string address = 30;
   */
  address = "";

  constructor(data?: PartialMessage<RemoveAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RemoveAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveAddressRequest | PlainMessage<RemoveAddressRequest> | undefined, b: RemoveAddressRequest | PlainMessage<RemoveAddressRequest> | undefined): boolean {
    return proto3.util.equals(RemoveAddressRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.RemoveAddressResponse
 */
export class RemoveAddressResponse extends Message<RemoveAddressResponse> {
  constructor(data?: PartialMessage<RemoveAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RemoveAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveAddressResponse | PlainMessage<RemoveAddressResponse> | undefined, b: RemoveAddressResponse | PlainMessage<RemoveAddressResponse> | undefined): boolean {
    return proto3.util.equals(RemoveAddressResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.SetBankAccountRequest
 */
export class SetBankAccountRequest extends Message<SetBankAccountRequest> {
  /**
   * first and last beneficiary name is not required. KYC info will be used as beneficiary name
   *
   * @generated from oneof ramp.v1.SetBankAccountRequest.bank_account
   */
  bankAccount: {
    /**
     * only for scheme SCAN
     *
     * @generated from field: ramp.v1.ScanCoordinates scan = 10;
     */
    value: ScanCoordinates;
    case: "scan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates iban = 20;
     */
    value: IbanCoordinates;
    case: "iban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SetBankAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.SetBankAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "scan", kind: "message", T: ScanCoordinates, oneof: "bank_account" },
    { no: 20, name: "iban", kind: "message", T: IbanCoordinates, oneof: "bank_account" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetBankAccountRequest | PlainMessage<SetBankAccountRequest> | undefined, b: SetBankAccountRequest | PlainMessage<SetBankAccountRequest> | undefined): boolean {
    return proto3.util.equals(SetBankAccountRequest, a, b);
  }
}

/**
 * The client should comply to basic validation rules such as min/max length for ibans, sort codes and account numbers
 * complex validation such as IBAN or SCAN checksums and sort code directory is performed by Harbour
 *
 * @generated from message ramp.v1.SetBankAccountResponse
 */
export class SetBankAccountResponse extends Message<SetBankAccountResponse> {
  /**
   * @generated from field: repeated ramp.v1.SetBankAccountResponse.Error errors = 10;
   */
  errors: SetBankAccountResponse_Error[] = [];

  constructor(data?: PartialMessage<SetBankAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.SetBankAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "errors", kind: "enum", T: proto3.getEnumType(SetBankAccountResponse_Error), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetBankAccountResponse | PlainMessage<SetBankAccountResponse> | undefined, b: SetBankAccountResponse | PlainMessage<SetBankAccountResponse> | undefined): boolean {
    return proto3.util.equals(SetBankAccountResponse, a, b);
  }
}

/**
 * @generated from enum ramp.v1.SetBankAccountResponse.Error
 */
export enum SetBankAccountResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returned when the routing code is wrong (eg: sort code for UK and BIC for ibans).
   * Note: the client still needs to perform basic validation, such as guaranteeing that the sort code is exactly 6 digits,
   * else it won't even get this response and just get a code invalid argument.
   * However, the backend will perform more advanced validation, such as checking that the sort code exists, in which
   * case it will return this error.
   *
   * @generated from enum value: ERROR_BANK_CODE_INVALID = 1;
   */
  BANK_CODE_INVALID = 1,

  /**
   * Same as above, but for the account number (eg: account number for UK and IBAN for ibans).
   * In case of UK account numbers, the account number is validated against the sort code, to determine whether it's
   * valid according to the destination bank.
   * In case of IBAN, basic mathematical checks will be performed, according to the IBAN standard, to verify its validity.
   *
   * @generated from enum value: ERROR_BANK_NUMBER_INVALID = 2;
   */
  BANK_NUMBER_INVALID = 2,

  /**
   * Returned when the user tries to set the bank account same as the magic-ramp account.
   *
   * @generated from enum value: ERROR_SAME_BANK_ACCOUNT = 3;
   */
  SAME_BANK_ACCOUNT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SetBankAccountResponse_Error)
proto3.util.setEnumType(SetBankAccountResponse_Error, "ramp.v1.SetBankAccountResponse.Error", [
  { no: 0, name: "ERROR_UNSPECIFIED" },
  { no: 1, name: "ERROR_BANK_CODE_INVALID" },
  { no: 2, name: "ERROR_BANK_NUMBER_INVALID" },
  { no: 3, name: "ERROR_SAME_BANK_ACCOUNT" },
]);

/**
 * @generated from message ramp.v1.EstimateOnRampFeeRequest
 */
export class EstimateOnRampFeeRequest extends Message<EstimateOnRampFeeRequest> {
  /**
   * All fields are mandatory
   *
   * @generated from field: ramp.v1.CurrencyId fiat_asset_id = 5;
   */
  fiatAssetId = CurrencyId.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 10;
   */
  cryptoAssetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 15;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from oneof ramp.v1.EstimateOnRampFeeRequest.amount
   */
  amount: {
    /**
     * @generated from field: string fiat_asset_amount = 20;
     */
    value: string;
    case: "fiatAssetAmount";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * this is optional and could be used by partners of Harbour
   *
   * @generated from oneof ramp.v1.EstimateOnRampFeeRequest.referral
   */
  referral: {
    /**
     * please reach out support to obtain referral code
     *
     * @generated from field: string code = 30;
     */
    value: string;
    case: "code";
  } | {
    /**
     * provide wallet_address if referral transaction was registered for this address
     *
     * @generated from field: string wallet_address = 40;
     */
    value: string;
    case: "walletAddress";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EstimateOnRampFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOnRampFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "fiat_asset_id", kind: "enum", T: proto3.getEnumType(CurrencyId) },
    { no: 10, name: "crypto_asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 15, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 20, name: "fiat_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "amount" },
    { no: 30, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "referral" },
    { no: 40, name: "wallet_address", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "referral" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOnRampFeeRequest {
    return new EstimateOnRampFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOnRampFeeRequest {
    return new EstimateOnRampFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOnRampFeeRequest {
    return new EstimateOnRampFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOnRampFeeRequest | PlainMessage<EstimateOnRampFeeRequest> | undefined, b: EstimateOnRampFeeRequest | PlainMessage<EstimateOnRampFeeRequest> | undefined): boolean {
    return proto3.util.equals(EstimateOnRampFeeRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.EstimateOnRampFeeResponse
 */
export class EstimateOnRampFeeResponse extends Message<EstimateOnRampFeeResponse> {
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string fiat_asset_amount = 20;
   */
  fiatAssetAmount = "";

  /**
   * denominated in crypto_asset
   *
   * @generated from field: string crypto_asset_amount = 30;
   */
  cryptoAssetAmount = "";

  /**
   * @generated from field: string exchange_rate = 40;
   */
  exchangeRate = "";

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string network_fee_amount = 50;
   */
  networkFeeAmount = "";

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string processing_fee_amount = 60;
   */
  processingFeeAmount = "";

  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "fiat_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "crypto_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "exchange_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "network_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "processing_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {no: 70, name: "referral_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */},
  ]);

  constructor(data?: PartialMessage<EstimateOnRampFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOnRampFeeResponse";
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string referral_fee_amount = 70;
   */
  referralFeeAmount = "";

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOnRampFeeResponse {
    return new EstimateOnRampFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOnRampFeeResponse {
    return new EstimateOnRampFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOnRampFeeResponse {
    return new EstimateOnRampFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOnRampFeeResponse | PlainMessage<EstimateOnRampFeeResponse> | undefined, b: EstimateOnRampFeeResponse | PlainMessage<EstimateOnRampFeeResponse> | undefined): boolean {
    return proto3.util.equals(EstimateOnRampFeeResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.EstimateOffRampFeeRequest
 */
export class EstimateOffRampFeeRequest extends Message<EstimateOffRampFeeRequest> {
  /**
   * optional - just for a transitional period
   *
   * @generated from field: ramp.v1.CurrencyId fiat_asset_id = 5;
   */
  fiatAssetId = CurrencyId.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 10;
   */
  cryptoAssetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 15;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from oneof ramp.v1.EstimateOffRampFeeRequest.amount
   */
  amount: {
    /**
     * @generated from field: string crypto_asset_amount = 20;
     */
    value: string;
    case: "cryptoAssetAmount";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * this is optional and could be used by partners of Harbour
   *
   * @generated from oneof ramp.v1.EstimateOffRampFeeRequest.referral
   */
  referral: {
    /**
     * please reach out support to obtain referral code
     *
     * @generated from field: string code = 30;
     */
    value: string;
    case: "code";
  } | {
    /**
     * provide wallet_address if referral transaction was registered for this address
     *
     * @generated from field: string wallet_address = 40;
     */
    value: string;
    case: "walletAddress";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EstimateOffRampFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOffRampFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "fiat_asset_id", kind: "enum", T: proto3.getEnumType(CurrencyId) },
    { no: 10, name: "crypto_asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 15, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 20, name: "crypto_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "amount" },
    { no: 30, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "referral" },
    { no: 40, name: "wallet_address", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "referral" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOffRampFeeRequest {
    return new EstimateOffRampFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOffRampFeeRequest {
    return new EstimateOffRampFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOffRampFeeRequest {
    return new EstimateOffRampFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOffRampFeeRequest | PlainMessage<EstimateOffRampFeeRequest> | undefined, b: EstimateOffRampFeeRequest | PlainMessage<EstimateOffRampFeeRequest> | undefined): boolean {
    return proto3.util.equals(EstimateOffRampFeeRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.EstimateOffRampFeeResponse
 */
export class EstimateOffRampFeeResponse extends Message<EstimateOffRampFeeResponse> {
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string fiat_asset_amount = 20;
   */
  fiatAssetAmount = "";

  /**
   * denominated in crypto_asset
   *
   * @generated from field: string crypto_asset_amount = 30;
   */
  cryptoAssetAmount = "";

  /**
   * @generated from field: string exchange_rate = 40;
   */
  exchangeRate = "";

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string processing_fee_amount = 60;
   */
  processingFeeAmount = "";

  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "fiat_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "crypto_asset_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "exchange_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "processing_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {no: 70, name: "referral_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */},
  ]);

  constructor(data?: PartialMessage<EstimateOffRampFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.EstimateOffRampFeeResponse";
  /**
   * @generated from field: string referral_fee_amount = 70;
   */
  referralFeeAmount = "";

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateOffRampFeeResponse {
    return new EstimateOffRampFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateOffRampFeeResponse {
    return new EstimateOffRampFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateOffRampFeeResponse {
    return new EstimateOffRampFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateOffRampFeeResponse | PlainMessage<EstimateOffRampFeeResponse> | undefined, b: EstimateOffRampFeeResponse | PlainMessage<EstimateOffRampFeeResponse> | undefined): boolean {
    return proto3.util.equals(EstimateOffRampFeeResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetRampsRequest
 */
export class GetRampsRequest extends Message<GetRampsRequest> {
  /**
   * if not set default page will be used (index=0, size=10)
   *
   * @generated from field: optional ramp.v1.Page page = 10;
   */
  page?: Page;

  /**
   * required
   *
   * @generated from field: ramp.v1.RampType ramp_type = 20;
   */
  rampType = RampType.UNSPECIFIED;

  /**
   * optional
   *
   * @generated from field: optional ramp.v1.GetRampsRequest.DateRange date_range = 30;
   */
  dateRange?: GetRampsRequest_DateRange;

  constructor(data?: PartialMessage<GetRampsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetRampsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "page", kind: "message", T: Page, opt: true },
    { no: 20, name: "ramp_type", kind: "enum", T: proto3.getEnumType(RampType) },
    { no: 30, name: "date_range", kind: "message", T: GetRampsRequest_DateRange, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRampsRequest {
    return new GetRampsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRampsRequest {
    return new GetRampsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRampsRequest {
    return new GetRampsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRampsRequest | PlainMessage<GetRampsRequest> | undefined, b: GetRampsRequest | PlainMessage<GetRampsRequest> | undefined): boolean {
    return proto3.util.equals(GetRampsRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetRampsRequest.DateRange
 */
export class GetRampsRequest_DateRange extends Message<GetRampsRequest_DateRange> {
  /**
   * @generated from field: google.protobuf.Timestamp from = 10;
   */
  from?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp to = 20;
   */
  to?: Timestamp;

  constructor(data?: PartialMessage<GetRampsRequest_DateRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetRampsRequest.DateRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "from", kind: "message", T: Timestamp },
    { no: 20, name: "to", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRampsRequest_DateRange {
    return new GetRampsRequest_DateRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRampsRequest_DateRange {
    return new GetRampsRequest_DateRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRampsRequest_DateRange {
    return new GetRampsRequest_DateRange().fromJsonString(jsonString, options);
  }

  static equals(a: GetRampsRequest_DateRange | PlainMessage<GetRampsRequest_DateRange> | undefined, b: GetRampsRequest_DateRange | PlainMessage<GetRampsRequest_DateRange> | undefined): boolean {
    return proto3.util.equals(GetRampsRequest_DateRange, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetRampsResponse
 */
export class GetRampsResponse extends Message<GetRampsResponse> {
  /**
   * @generated from field: ramp.v1.PagedResult page = 10;
   */
  page?: PagedResult;

  /**
   * @generated from field: repeated ramp.v1.GetRampsResponse.Ramp ramps = 20;
   */
  ramps: GetRampsResponse_Ramp[] = [];

  constructor(data?: PartialMessage<GetRampsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetRampsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "page", kind: "message", T: PagedResult },
    { no: 20, name: "ramps", kind: "message", T: GetRampsResponse_Ramp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRampsResponse {
    return new GetRampsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRampsResponse {
    return new GetRampsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRampsResponse {
    return new GetRampsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRampsResponse | PlainMessage<GetRampsResponse> | undefined, b: GetRampsResponse | PlainMessage<GetRampsResponse> | undefined): boolean {
    return proto3.util.equals(GetRampsResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetRampsResponse.Ramp
 */
export class GetRampsResponse_Ramp extends Message<GetRampsResponse_Ramp> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * @generated from field: ramp.v1.RampType type = 20;
   */
  type = RampType.UNSPECIFIED;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: ramp.v1.AssetId crypto_asset = 30;
   */
  cryptoAsset = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string fiat_amount = 40;
   */
  fiatAmount = "";

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string crypto_amount = 50;
   */
  cryptoAmount = "";

  /**
   * string exchange_rate = 60; // could be empty if ramp is not completed yet
   *
   * @generated from field: ramp.v1.Protocol wallet_protocol = 70;
   */
  walletProtocol = Protocol.UNSPECIFIED;

  /**
   * @generated from field: string wallet_address = 80;
   */
  walletAddress = "";

  /**
   * in fiat, could be empty if ramp is not completed yet
   *
   * @generated from field: string network_fee_amount = 90;
   */
  networkFeeAmount = "";

  /**
   * in fiat, could be empty if ramp is not completed yet
   *
   * @generated from field: string processing_fee_amount = 100;
   */
  processingFeeAmount = "";

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: google.protobuf.Timestamp finalized_at = 110;
   */
  finalizedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp initiated_at = 120;
   */
  initiatedAt?: Timestamp;

  constructor(data?: PartialMessage<GetRampsResponse_Ramp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetRampsResponse.Ramp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "type", kind: "enum", T: proto3.getEnumType(RampType) },
    { no: 30, name: "crypto_asset", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 40, name: "fiat_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "crypto_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 70, name: "wallet_protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 80, name: "wallet_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 90, name: "network_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 100, name: "processing_fee_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 110, name: "finalized_at", kind: "message", T: Timestamp },
    { no: 120, name: "initiated_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRampsResponse_Ramp {
    return new GetRampsResponse_Ramp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRampsResponse_Ramp {
    return new GetRampsResponse_Ramp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRampsResponse_Ramp {
    return new GetRampsResponse_Ramp().fromJsonString(jsonString, options);
  }

  static equals(a: GetRampsResponse_Ramp | PlainMessage<GetRampsResponse_Ramp> | undefined, b: GetRampsResponse_Ramp | PlainMessage<GetRampsResponse_Ramp> | undefined): boolean {
    return proto3.util.equals(GetRampsResponse_Ramp, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAssetsRequest
 */
export class GetAssetsRequest extends Message<GetAssetsRequest> {
  /**
   * @generated from field: ramp.v1.CurrencyId fiat_asset_id = 10;
   */
  fiatAssetId = CurrencyId.UNSPECIFIED;

  constructor(data?: PartialMessage<GetAssetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAssetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "fiat_asset_id", kind: "enum", T: proto3.getEnumType(CurrencyId) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAssetsRequest {
    return new GetAssetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAssetsRequest {
    return new GetAssetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAssetsRequest {
    return new GetAssetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAssetsRequest | PlainMessage<GetAssetsRequest> | undefined, b: GetAssetsRequest | PlainMessage<GetAssetsRequest> | undefined): boolean {
    return proto3.util.equals(GetAssetsRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAssetsResponse
 */
export class GetAssetsResponse extends Message<GetAssetsResponse> {
  /**
   * @generated from field: repeated ramp.v1.CryptoAsset crypto_assets = 10;
   */
  cryptoAssets: CryptoAsset[] = [];

  constructor(data?: PartialMessage<GetAssetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAssetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "crypto_assets", kind: "message", T: CryptoAsset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAssetsResponse {
    return new GetAssetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAssetsResponse {
    return new GetAssetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAssetsResponse {
    return new GetAssetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAssetsResponse | PlainMessage<GetAssetsResponse> | undefined, b: GetAssetsResponse | PlainMessage<GetAssetsResponse> | undefined): boolean {
    return proto3.util.equals(GetAssetsResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.RegisterReferralTransactionRequest
 */
export class RegisterReferralTransactionRequest extends Message<RegisterReferralTransactionRequest> {
  /**
   * assigned to the partner by Harbour
   *
   * @generated from field: string referral_code = 10;
   */
  referralCode = "";

  /**
   * @generated from field: string wallet_address = 20;
   */
  walletAddress = "";

  /**
   * @generated from field: ramp.v1.RampType type = 30;
   */
  type = RampType.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.CurrencyId currency = 40;
   */
  currency = CurrencyId.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.AssetId crypto_asset = 50;
   */
  cryptoAsset = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Protocol crypto_asset_protocol = 60;
   */
  cryptoAssetProtocol = Protocol.UNSPECIFIED;

  /**
   * client generated id of transaction, will be reported back in the webhook
   *
   * @generated from field: string referral_transaction_id = 70;
   */
  referralTransactionId = "";

  /**
   * fiat amount for on ramps, crypto amount for off ramps
   *
   * @generated from field: string amount = 80;
   */
  amount = "";

  constructor(data?: PartialMessage<RegisterReferralTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RegisterReferralTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "referral_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "wallet_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "type", kind: "enum", T: proto3.getEnumType(RampType) },
    { no: 40, name: "currency", kind: "enum", T: proto3.getEnumType(CurrencyId) },
    { no: 50, name: "crypto_asset", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 60, name: "crypto_asset_protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 70, name: "referral_transaction_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 80, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterReferralTransactionRequest {
    return new RegisterReferralTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterReferralTransactionRequest {
    return new RegisterReferralTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterReferralTransactionRequest {
    return new RegisterReferralTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterReferralTransactionRequest | PlainMessage<RegisterReferralTransactionRequest> | undefined, b: RegisterReferralTransactionRequest | PlainMessage<RegisterReferralTransactionRequest> | undefined): boolean {
    return proto3.util.equals(RegisterReferralTransactionRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.RegisterReferralTransactionResponse
 */
export class RegisterReferralTransactionResponse extends Message<RegisterReferralTransactionResponse> {
  constructor(data?: PartialMessage<RegisterReferralTransactionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RegisterReferralTransactionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterReferralTransactionResponse {
    return new RegisterReferralTransactionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterReferralTransactionResponse {
    return new RegisterReferralTransactionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterReferralTransactionResponse {
    return new RegisterReferralTransactionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterReferralTransactionResponse | PlainMessage<RegisterReferralTransactionResponse> | undefined, b: RegisterReferralTransactionResponse | PlainMessage<RegisterReferralTransactionResponse> | undefined): boolean {
    return proto3.util.equals(RegisterReferralTransactionResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset
 */
export class CryptoAsset extends Message<CryptoAsset> {
  /**
   * asset status for on/off ramping
   *
   * @generated from field: ramp.v1.CryptoAsset.RampStatus status = 10;
   */
  status?: CryptoAsset_RampStatus;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 20;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Network network = 30;
   */
  network = Network.UNSPECIFIED;

  /**
   * the client can use this to match an asset with precision and display custom wording / icon, e.g. "USDC"
   *
   * @generated from field: ramp.v1.AssetId asset_id = 40;
   */
  assetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
   *
   * @generated from field: string short_name = 50;
   */
  shortName = "";

  /**
   * the canonical symbol for the asset - eg: USDC for any Circle-issued USDC on any chain, or ETH for Ethereum
   *
   * @generated from field: string symbol = 55;
   */
  symbol = "";

  /**
   * @generated from oneof ramp.v1.CryptoAsset.details
   */
  details: {
    /**
     * @generated from field: ramp.v1.CryptoAsset.EthereumErc20Token ethereum_erc20_token = 60;
     */
    value: CryptoAsset_EthereumErc20Token;
    case: "ethereumErc20Token";
  } | {
    /**
     * @generated from field: ramp.v1.CryptoAsset.CosmosIcs20Token cosmos_ics20_token = 70;
     */
    value: CryptoAsset_CosmosIcs20Token;
    case: "cosmosIcs20Token";
  } | {
    /**
     * @generated from field: ramp.v1.CryptoAsset.SubstratePsp22Token substrate_psp22_token = 80;
     */
    value: CryptoAsset_SubstratePsp22Token;
    case: "substratePsp22Token";
  } | {
    /**
     * @generated from field: ramp.v1.CryptoAsset.EthereumNative ethereum_native = 90;
     */
    value: CryptoAsset_EthereumNative;
    case: "ethereumNative";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits onramp_limits = 100;
   */
  onrampLimits?: CryptoAsset_Limits;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits offramp_limits = 110;
   */
  offrampLimits?: CryptoAsset_Limits;

  constructor(data?: PartialMessage<CryptoAsset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "status", kind: "message", T: CryptoAsset_RampStatus },
    { no: 20, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 30, name: "network", kind: "enum", T: proto3.getEnumType(Network) },
    { no: 40, name: "asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 50, name: "short_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 55, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "ethereum_erc20_token", kind: "message", T: CryptoAsset_EthereumErc20Token, oneof: "details" },
    { no: 70, name: "cosmos_ics20_token", kind: "message", T: CryptoAsset_CosmosIcs20Token, oneof: "details" },
    { no: 80, name: "substrate_psp22_token", kind: "message", T: CryptoAsset_SubstratePsp22Token, oneof: "details" },
    { no: 90, name: "ethereum_native", kind: "message", T: CryptoAsset_EthereumNative, oneof: "details" },
    { no: 100, name: "onramp_limits", kind: "message", T: CryptoAsset_Limits },
    { no: 110, name: "offramp_limits", kind: "message", T: CryptoAsset_Limits },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset {
    return new CryptoAsset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset {
    return new CryptoAsset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset {
    return new CryptoAsset().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset | PlainMessage<CryptoAsset> | undefined, b: CryptoAsset | PlainMessage<CryptoAsset> | undefined): boolean {
    return proto3.util.equals(CryptoAsset, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset.EthereumErc20Token
 */
export class CryptoAsset_EthereumErc20Token extends Message<CryptoAsset_EthereumErc20Token> {
  /**
   * ERC20 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress = "";

  constructor(data?: PartialMessage<CryptoAsset_EthereumErc20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.EthereumErc20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_EthereumErc20Token {
    return new CryptoAsset_EthereumErc20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_EthereumErc20Token {
    return new CryptoAsset_EthereumErc20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_EthereumErc20Token {
    return new CryptoAsset_EthereumErc20Token().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_EthereumErc20Token | PlainMessage<CryptoAsset_EthereumErc20Token> | undefined, b: CryptoAsset_EthereumErc20Token | PlainMessage<CryptoAsset_EthereumErc20Token> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_EthereumErc20Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset.CosmosIcs20Token
 */
export class CryptoAsset_CosmosIcs20Token extends Message<CryptoAsset_CosmosIcs20Token> {
  /**
   * IBC token address
   *
   * @generated from field: string ibc_address = 10;
   */
  ibcAddress = "";

  constructor(data?: PartialMessage<CryptoAsset_CosmosIcs20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.CosmosIcs20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "ibc_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_CosmosIcs20Token {
    return new CryptoAsset_CosmosIcs20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_CosmosIcs20Token {
    return new CryptoAsset_CosmosIcs20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_CosmosIcs20Token {
    return new CryptoAsset_CosmosIcs20Token().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_CosmosIcs20Token | PlainMessage<CryptoAsset_CosmosIcs20Token> | undefined, b: CryptoAsset_CosmosIcs20Token | PlainMessage<CryptoAsset_CosmosIcs20Token> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_CosmosIcs20Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset.SubstratePsp22Token
 */
export class CryptoAsset_SubstratePsp22Token extends Message<CryptoAsset_SubstratePsp22Token> {
  /**
   * Substrate PSP22 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress = "";

  constructor(data?: PartialMessage<CryptoAsset_SubstratePsp22Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.SubstratePsp22Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_SubstratePsp22Token {
    return new CryptoAsset_SubstratePsp22Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_SubstratePsp22Token {
    return new CryptoAsset_SubstratePsp22Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_SubstratePsp22Token {
    return new CryptoAsset_SubstratePsp22Token().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_SubstratePsp22Token | PlainMessage<CryptoAsset_SubstratePsp22Token> | undefined, b: CryptoAsset_SubstratePsp22Token | PlainMessage<CryptoAsset_SubstratePsp22Token> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_SubstratePsp22Token, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset.EthereumNative
 */
export class CryptoAsset_EthereumNative extends Message<CryptoAsset_EthereumNative> {
  constructor(data?: PartialMessage<CryptoAsset_EthereumNative>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.EthereumNative";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_EthereumNative {
    return new CryptoAsset_EthereumNative().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_EthereumNative {
    return new CryptoAsset_EthereumNative().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_EthereumNative {
    return new CryptoAsset_EthereumNative().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_EthereumNative | PlainMessage<CryptoAsset_EthereumNative> | undefined, b: CryptoAsset_EthereumNative | PlainMessage<CryptoAsset_EthereumNative> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_EthereumNative, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset.RampStatus
 */
export class CryptoAsset_RampStatus extends Message<CryptoAsset_RampStatus> {
  /**
   * @generated from field: ramp.v1.CryptoAsset.RampStatus.Status onramp = 10;
   */
  onramp = CryptoAsset_RampStatus_Status.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.CryptoAsset.RampStatus.Status offramp = 20;
   */
  offramp = CryptoAsset_RampStatus_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<CryptoAsset_RampStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.RampStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "onramp", kind: "enum", T: proto3.getEnumType(CryptoAsset_RampStatus_Status) },
    { no: 20, name: "offramp", kind: "enum", T: proto3.getEnumType(CryptoAsset_RampStatus_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_RampStatus {
    return new CryptoAsset_RampStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_RampStatus {
    return new CryptoAsset_RampStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_RampStatus {
    return new CryptoAsset_RampStatus().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_RampStatus | PlainMessage<CryptoAsset_RampStatus> | undefined, b: CryptoAsset_RampStatus | PlainMessage<CryptoAsset_RampStatus> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_RampStatus, a, b);
  }
}

/**
 * @generated from enum ramp.v1.CryptoAsset.RampStatus.Status
 */
export enum CryptoAsset_RampStatus_Status {
  /**
   * All is good, asset can be on/off ramped
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Our system is experiencing degradation (longer waits) but still operational.
   * The UI should warn users.
   *
   * @generated from enum value: STATUS_DEGRADED = 20;
   */
  DEGRADED = 20,

  /**
   * Exceptional scenarios: ramping halted. The UI should prevent users from taking any action.
   *
   * @generated from enum value: STATUS_HALTED = 30;
   */
  HALTED = 30,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoAsset_RampStatus_Status)
proto3.util.setEnumType(CryptoAsset_RampStatus_Status, "ramp.v1.CryptoAsset.RampStatus.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 20, name: "STATUS_DEGRADED" },
  { no: 30, name: "STATUS_HALTED" },
]);

/**
 * @generated from message ramp.v1.CryptoAsset.Limits
 */
export class CryptoAsset_Limits extends Message<CryptoAsset_Limits> {
  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount single_limit_amount = 10;
   */
  singleLimitAmount?: CryptoAsset_Limits_Amount;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount daily_limit_amount = 20;
   */
  dailyLimitAmount?: CryptoAsset_Limits_Amount;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount daily_used_amount = 30;
   */
  dailyUsedAmount?: CryptoAsset_Limits_Amount;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount daily_remaining_amount = 40;
   */
  dailyRemainingAmount?: CryptoAsset_Limits_Amount;

  constructor(data?: PartialMessage<CryptoAsset_Limits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.Limits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "single_limit_amount", kind: "message", T: CryptoAsset_Limits_Amount },
    { no: 20, name: "daily_limit_amount", kind: "message", T: CryptoAsset_Limits_Amount },
    { no: 30, name: "daily_used_amount", kind: "message", T: CryptoAsset_Limits_Amount },
    { no: 40, name: "daily_remaining_amount", kind: "message", T: CryptoAsset_Limits_Amount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_Limits {
    return new CryptoAsset_Limits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_Limits {
    return new CryptoAsset_Limits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_Limits {
    return new CryptoAsset_Limits().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_Limits | PlainMessage<CryptoAsset_Limits> | undefined, b: CryptoAsset_Limits | PlainMessage<CryptoAsset_Limits> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_Limits, a, b);
  }
}

/**
 * @generated from message ramp.v1.CryptoAsset.Limits.Amount
 */
export class CryptoAsset_Limits_Amount extends Message<CryptoAsset_Limits_Amount> {
  /**
   * @generated from field: string asset = 10;
   */
  asset = "";

  /**
   * @generated from field: string fiat = 20;
   */
  fiat = "";

  constructor(data?: PartialMessage<CryptoAsset_Limits_Amount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.CryptoAsset.Limits.Amount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "asset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "fiat", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoAsset_Limits_Amount {
    return new CryptoAsset_Limits_Amount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoAsset_Limits_Amount {
    return new CryptoAsset_Limits_Amount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoAsset_Limits_Amount {
    return new CryptoAsset_Limits_Amount().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoAsset_Limits_Amount | PlainMessage<CryptoAsset_Limits_Amount> | undefined, b: CryptoAsset_Limits_Amount | PlainMessage<CryptoAsset_Limits_Amount> | undefined): boolean {
    return proto3.util.equals(CryptoAsset_Limits_Amount, a, b);
  }
}

/**
 * @generated from message ramp.v1.ScanCoordinates
 */
export class ScanCoordinates extends Message<ScanCoordinates> {
  /**
   * always 8 digits
   *
   * @generated from field: string account_number = 10;
   */
  accountNumber = "";

  /**
   * always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
   *
   * @generated from field: string sort_code = 20;
   */
  sortCode = "";

  constructor(data?: PartialMessage<ScanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.ScanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "sort_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined, b: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined): boolean {
    return proto3.util.equals(ScanCoordinates, a, b);
  }
}

/**
 * @generated from message ramp.v1.IbanCoordinates
 */
export class IbanCoordinates extends Message<IbanCoordinates> {
  /**
   * up to 34 characters (please submit them all uppercase) and numbers
   *
   * @generated from field: string iban = 10;
   */
  iban = "";

  constructor(data?: PartialMessage<IbanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.IbanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "iban", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined, b: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined): boolean {
    return proto3.util.equals(IbanCoordinates, a, b);
  }
}

/**
 * used in the webhook for partners (by default in the JSON format)
 *
 * @generated from message ramp.v1.RampTransaction
 */
export class RampTransaction extends Message<RampTransaction> {
  /**
   * @generated from field: string transaction_id = 10;
   */
  transactionId = "";

  /**
   * @generated from field: string referral_transaction_id = 20;
   */
  referralTransactionId = "";

  /**
   * @generated from field: ramp.v1.RampType type = 30;
   */
  type = RampType.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.RampStatus status = 40;
   */
  status = RampStatus.UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.CurrencyId currency = 50;
   */
  currency = CurrencyId.UNSPECIFIED;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 60;
   */
  cryptoAssetId = AssetId.ASSET_ID_UNSPECIFIED;

  /**
   * @generated from field: ramp.v1.Protocol crypto_asset_protocol = 70;
   */
  cryptoAssetProtocol = Protocol.UNSPECIFIED;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string fiat_amount = 80;
   */
  fiatAmount = "";

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string crypto_amount = 90;
   */
  cryptoAmount = "";

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string exchange_rate = 100;
   */
  exchangeRate = "";

  /**
   * not set if ramp is not completed yet
   *
   * @generated from field: ramp.v1.RampTransaction.Fees fees = 110;
   */
  fees?: RampTransaction_Fees;

  /**
   * @generated from field: string wallet_address = 120;
   */
  walletAddress = "";

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: google.protobuf.Timestamp finalized_at = 130;
   */
  finalizedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp initiated_at = 140;
   */
  initiatedAt?: Timestamp;

  constructor(data?: PartialMessage<RampTransaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RampTransaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "transaction_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "referral_transaction_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "type", kind: "enum", T: proto3.getEnumType(RampType) },
    { no: 40, name: "status", kind: "enum", T: proto3.getEnumType(RampStatus) },
    { no: 50, name: "currency", kind: "enum", T: proto3.getEnumType(CurrencyId) },
    { no: 60, name: "crypto_asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 70, name: "crypto_asset_protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 80, name: "fiat_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 90, name: "crypto_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 100, name: "exchange_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 110, name: "fees", kind: "message", T: RampTransaction_Fees },
    { no: 120, name: "wallet_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 130, name: "finalized_at", kind: "message", T: Timestamp },
    { no: 140, name: "initiated_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RampTransaction {
    return new RampTransaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RampTransaction {
    return new RampTransaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RampTransaction {
    return new RampTransaction().fromJsonString(jsonString, options);
  }

  static equals(a: RampTransaction | PlainMessage<RampTransaction> | undefined, b: RampTransaction | PlainMessage<RampTransaction> | undefined): boolean {
    return proto3.util.equals(RampTransaction, a, b);
  }
}

/**
 * @generated from message ramp.v1.RampTransaction.Fees
 */
export class RampTransaction_Fees extends Message<RampTransaction_Fees> {
  /**
   * in fiat currency
   *
   * @generated from field: string processing = 10;
   */
  processing = "";

  /**
   * in fiat currency
   *
   * @generated from field: string network = 20;
   */
  network = "";

  /**
   * in fiat currency
   *
   * @generated from field: string referral = 30;
   */
  referral = "";

  constructor(data?: PartialMessage<RampTransaction_Fees>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RampTransaction.Fees";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "processing", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "referral", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RampTransaction_Fees {
    return new RampTransaction_Fees().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RampTransaction_Fees {
    return new RampTransaction_Fees().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RampTransaction_Fees {
    return new RampTransaction_Fees().fromJsonString(jsonString, options);
  }

  static equals(a: RampTransaction_Fees | PlainMessage<RampTransaction_Fees> | undefined, b: RampTransaction_Fees | PlainMessage<RampTransaction_Fees> | undefined): boolean {
    return proto3.util.equals(RampTransaction_Fees, a, b);
  }
}

/**
 * @generated from message ramp.v1.Page
 */
export class Page extends Message<Page> {
  /**
   * zero based numbering
   *
   * @generated from field: optional uint64 index = 10;
   */
  index?: bigint;

  /**
   * max 100
   *
   * @generated from field: optional uint64 size = 20;
   */
  size?: bigint;

  constructor(data?: PartialMessage<Page>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.Page";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 20, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Page {
    return new Page().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Page {
    return new Page().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Page {
    return new Page().fromJsonString(jsonString, options);
  }

  static equals(a: Page | PlainMessage<Page> | undefined, b: Page | PlainMessage<Page> | undefined): boolean {
    return proto3.util.equals(Page, a, b);
  }
}

/**
 * @generated from message ramp.v1.PagedResult
 */
export class PagedResult extends Message<PagedResult> {
  /**
   * zero based numbering
   *
   * @generated from field: uint64 index = 10;
   */
  index = protoInt64.zero;

  /**
   * @generated from field: uint64 size = 20;
   */
  size = protoInt64.zero;

  /**
   * true if next page is available
   *
   * @generated from field: bool has_more = 30;
   */
  hasMore = false;

  constructor(data?: PartialMessage<PagedResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PagedResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 20, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 30, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PagedResult {
    return new PagedResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PagedResult {
    return new PagedResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PagedResult {
    return new PagedResult().fromJsonString(jsonString, options);
  }

  static equals(a: PagedResult | PlainMessage<PagedResult> | undefined, b: PagedResult | PlainMessage<PagedResult> | undefined): boolean {
    return proto3.util.equals(PagedResult, a, b);
  }
}

